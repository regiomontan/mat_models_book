
\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Отладка кода вдвое сложнее, чем его написание. Так что если вы пишете
                 код настолько умно, насколько можете, то вы по определению недостаточно
                 сообразительны, чтобы его отлаживать.
                 }} \\
                 %\end{flushright}
                 %\begin{flushright}
                 \emph{Брайан Керниган} \\
\end{flushright}
\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Всегда пишите код так, будто сопровождать его будет склонный к насилию
                 психопат, который знает, где вы живете.
                 }} \\
                 %\end{flushright}
                 %\begin{flushright}
                 \emph{Мартин Голдинг}
\end{flushright}

\subsection{Оптимизация программ по времени выполнения} \label{optimize_time}

Для подавляющего большинства программ основная часть времени их
 исполнения
 расходуется на выполнение небольших участков кода, который
 называют {\it критичным} или {\it внутренним} циклом. Именно с
 этих программных блоков нужно начинать оптимизацию (и, в большинстве случаев, ими можно
 и ограничиться).
           Большая часть кода, обычно до $80$--$90$\%, не нуждается
           ни в какой оптимизации.

 Как
 правило, этот код действительно является циклом в смысле синтаксиса языков
 программирования. Если программа содержит несколько вложенных
 друг в друга циклов, то внутренний~--- это цикл, принадлежащий
 всем циклам. Если имеется несколько циклов, не содержащих
 вложенных циклов, то нужно оценить время их работы, подсчитав
 количество повторений каждого из них.

 \emph{Пример.} Рассмотрим следующий блок операторов
 %%================================================================================
  \begin{lstlisting}
    for j := 1 to N do  // цикл 1;
    begin
       for k := 1 to M do
       begin
       // тело цикла 2;
       end;
       for l := N downto j do
       begin
       // тело цикла 3;
       end;
    end;               // конец цикла 1;
 \end{lstlisting}
%%================================================================================

Время работы программы, помимо всего прочего, зависит от
 характеристик компьютера (<<железа>>), на котором программа выполняется.
 Поэтому заранее точно установить время работы того или иного алгоритма
 практически невозможно и обычно используют приближённые оценки.

 Пусть время одного прогона тела циклов $2$ и $3$ приближённо равно,
 соответственно, $T_2$ и $T_3$ (если это время не является постоянным, например, в теле цикла
 имеется условный переход или вызов подпрограммы, то нужно взять среднее
 время). Операторы тела цикла $2$ выполняются $MN$ раз, а цикла $3$~---
 всего $N - j + 1$ раз при каждом прогоне цикла~$1$. Следовательно, общее
 количество итераций цикла $3$ равно
 %%-------------------------------------------------------------------------------
 $$
 \sum_{j = 1}^{N} (N - j + 1) = \frac{1}{2}\,N(N - 1).
 $$
 %%-------------------------------------------------------------------------------
 А время работы всего блока
%%-------------------------------------------------------------------------------
 $$
 MN\,T_2 + \frac{1}{2}\,N(N + 1)T_3.
 $$
 %%-------------------------------------------------------------------------------
 Какой из циклов в данном случае будет критичным зависит от
 конкретных значений величин $M$, $N$, $T_2$, $T_3$. В более сложных
 случаях можно воспользоваться специально предназначенными для этих целей
 программами~--- профайлерами (profiler) \cite{KASPERSKY}.

 После того, как определены критические участки кода, можно
 приступать к оптимизации. Следующие советы могут помочь повысить
 быстродействие:
 \begin{itemize}
 \item Никогда не полагайтесь на автоматическую оптимизацию кода
 компилятором\footnote{<<Вера в могущество компиляторов в своем корне абсолютно безосновательна.
Хороший оптимизирующий компилятор по большому счету может похвастаться лишь своим умением
эффективно транслировать грамотно спроектированный код, т.\,е. если он не сильно ухудшает
исходную программу, то
уже только за это его разработчикам следует сказать \glqqспасибо\grqq.
Изначально \glqqкривой\grqq~код не исправит никакой компилятор, и оптимизирующий "---
в том числе>>~\cite{KASPERSKY}.}.
 \item По возможности, старайтесь исключить операции с плавающей
           точкой, так как они выполняются много медленнее, чем манипуляции с
           целыми величинами.
 \item Целочисленное умножение (деление) лучше
           заменить сложением (вычитанием), или, ещё лучше, \emph{сдвигами}.
           Например, вместо: \lstinline!k := k*11;! можно использовать
           \lstinline!k := k shl 3 +!
           \lstinline!k shl 1 + k;!, поскольку $11 = 2^{3} + 2 + 1$.
 \item Так как перед каждым вызовом процедуры или функции её
           параметры помещаются в стек, а затем изымаются оттуда, то поцедуры
           лучше спроектировать так, чтобы они имели как можно меньше
           параметров.
 \item Если есть возможность не выполнять какие-либо расчёты в реальном
           времени, можно их предварительно подготовить.
 \item В самых критических случаях можно использовать язык Assembler,
           программирование на котором более трудоёмко по сравнению с языками высокого
           уровня, но обеспечивает максимальную скорость выполнения программы.
 \end{itemize}

 Следует отметить, что самым лучшим способом оптимизации
 является \emph{выбор более эффективного алгоритма}~--- пузырьковая сортировка
 будет всегда идти медленно, несмотря на все программисткие трюки и ухищрения \cite{KNUTH}.

\subsection{Тестирование и отладка программ} \label{texting_debugging}

Ошибки в программах могут быть трёх видов:
\begin{itemize}
  \item Cинтаксические ошибки, вызванные тем, что программист нарушил правила языка
        программирования.
  \item Ошибки периода выполнения программы, когда синтаксически правильная программа
        работает не верно (или вообще не работает), например, ошибка <<деление на $0$>>, или
        <<бесконечный цикл>>.
  \item Логические ошибки, связанные с тем, что неправильно запрограммирован алгоритм, или
        сам алгоритм неверен.
\end{itemize}

 Синтаксические ошибки {\it автоматически} обнаруживаются при
 трансляции, причём компилятор выдаёт соответствующее сообщение о
 том, где произошла ошибка и возможных её причинах.

 Ошибки двух других типов более неприятны и коварны, так как они
 могут проявляться не при всех наборах входных данных, а только
 при некоторых, или при возникновении каких-то конкретных
 обстоятельств. Эти ошибки устраняются при помощи отладки и
 тестирования программ.

В настоящее время не существует теории тестирования и отладки,
применение которой гарантировало бы выявление всех возможных ошибок.
Отсюда следует, что любая более или менее сложная программа
\emph{почти неизбежно} содержит ошибки. Некоторые из них можно
устранить посредством отладки, при этом, быть может, внеся в
           программу новые ошибки. В связи с этим очевидна необходимость написания
           программного продукта с учётом последующего
           \emph{сопровождения}.

Отладка и тестирование программы~--- искусство, где нет строго
 определённых правил и где реально наиболее ярко проявляется квалификация
 программиста.

 Следующие три простых совета, возможно, помогут значительно облегчить отладку:
 \begin{itemize}
 \item Лучше сначала отладить процедуры, функции, объекты и т.\,д. по отдельности, а
       затем уже проверить их взаимодействие в программе в целом.
 \item При отладке особое внимание нужно уделить наиболее потенциально уязвимым
       участкам кода, таким, как \emph{циклы} и \emph{ветвления}, \emph{рекурсивные функции},
       а также всем программным объектам, связанным с
       работой с динамической памятью, \emph{указателями}, пользовательским вводом данных и
       т.\,п.
 \item При необходимости можно воспользоваться отладчиком (debugger), который сейчас имется
       в составе почти любой IDE, и который позволяет пошагово выполнять
       программу, от оператора к оператору, расставлять точки
       прерывания и т.\,д. Причём при отладке дебаггером на каждом шаге выполнения будет
       доступна вся
       информация о текущем состоянии всех элементов программы.
 \end{itemize}

 Под {\it тестированием} понимается выполнение программы с
 набором таких входных данных, при которых результат работы
 программы известен заранее. Цель тестирования~--- определение
 логических ошибок в программе. Конечно, прохождение набора тестов
 \emph{не гарантирует} логическую правильность в достаточно сложных программных
 проектах. С другой стороны, провал любого теста \emph{всегда} означает, что программный код
 нуждается в исправлении.
 Логическую правильность программы обычно удаётся доказать только
 в относительно простых случаях.

 При тестировании рекомендуются следующие правила:
 \begin{itemize}
  \item Составление тестов лучше проводить параллельно с разработкой
           программы.
  \item Сравнение эталонных и полученных значений предпочтительнее
           проводить в ходе самого теста.
 \item Программа должна не только правильно работать при корректных
           входных данных, но и уметь обрабатывать недопустимые для данной программы входные
           параметры.
  \item Все тесты нужно тщательно анализировать. При существенном изменении
           програмного кода, скорее всего, понадобится модифицировать и набор тестов.
 \end{itemize}

 Рассмотрим в качестве простого примера вычисление выражения
 $$%%------------------------
  \frac{e^{x} - 1}{x}.
$$%%------------------------
 Тестирование функции
 %%================================================================================
 \label{exp_div_v_listing_1}
 \begin{lstlisting}
 function exp_div_x( x: double ): double;
 begin
 result := ( exp( x ) - 1 )/x;
 end;
 \end{lstlisting}
 %%================================================================================
 даст следующие результаты
  \begin{center}
  \begin{tabular}{|c|l|l|}
  \hline
   \vrule width 0mm height 16pt
   № теста  &  значение  x & результат вызова функции\\
  \hline
  \hline
   1        &  1.0         & 1.71828182845905\,E+0000 \phantom{$\int_I^I$} \\
   2        &  0.0         & Invalid floating point operation \\
   3        & -1.0         & 6.32120558828558\,E-0001  \\
   4        & 1000.0       & Floating point overflow \\
   5        & 1.0\,E-3     &  1.00050016670834\,E+0000 \\
   6        & 1.0\,E-1000  & Invalid floating point operation\\
  \hline
  \end{tabular}
  \end{center}

Причина неправильной работы функции в тесте №2~--- деление на
  нуль, которое согласно стандарту  формата представления чисел с плавающей точкой
  \textsc{IEEE}~754 должно приводить к нечисловым значениям {\small +INF} или {\small -INF},
  но, в зависимости от языка программирования,  может также сгенерировать исключение,
  сообщение об ошибке, остановку выполняемой программы или привести к специальному
  нечисловому значению {\small NaN} (Not-a-Number).

   Поскольку
  $$
  \lim_{x \rightarrow 0} \frac{e^x - 1}{x} = 1,
  $$
 то эту логическую ошибку можно исправить так:
 %%================================================================================
 \label{exp_div_v_listing_2}
 \begin{lstlisting}
 function exp_div_x( x: double ): double;
 begin
    if   ( x = 0.0 ) then  result := 1.0
    else  result := ( exp( x ) - 1 )/x;
 end;
 \end{lstlisting}
%%================================================================================

Сбои в тестах №4 и №6 вызваны выходом за допустимый диапазон
 изменения величины типа double, который в Delphi составляет
 $$
 5{,}0 \times 10^{-324} \dots 1{,}7 \times 10^{308}.
 $$

 Для решения
 таких проблем можно, например, воспользоваться механизмом
 \emph{обработки исключительных ситуаций} (exception handling), который применяется в Object
 Pascal, C$++$, Java и других языках.

 %%================================================================================
\label{exp_div_v_listing_3}
 \begin{lstlisting}
 function exp_div_x( x: double ): double;
 begin
    if    ( x = 0.0 ) then  result := 1.0
    else  begin
              try
              // если при выполнении
              result := ( exp( x ) - 1 )/x;
              // возникла исключительная ситуация, то
              except
                   On EOverFlow do
                   begin
                   // если используется GUI Windows, то
                   // можно использовать процедуру
                   // ShowMessage('result is too large!');
                   // из модуля Dialogs,
                   // а для консольных приложений:
                   write('result is too large!');
                   result := 0.0;
                   end;
              end;
          end;
 end;
 \end{lstlisting}
%%================================================================================
Теперь в случае вещественного переполнения будет выдано
 сообщение: <<result is too large!>> (<<результат вычисления сликом велик!>>) и функция
 вернёт $0{,}0$.
 Возвращаемое значение сознательно выбрано невозможным для данной функции
 (она обращается в нуль только при $x \rightarrow -\infty$ и этого, конечно,
 не может произойти при вычислениях),
 чтобы по этой величине можно было впоследствии в вызывающем функцию
 блоке соответствующим образом обработать эту ситуацию.
 Применение программных исключений особенно удобно для глубоко вложенных
 блоков операторов, но следует учитывать, как следствие, неизбежное снижение скорости
 работы программы и усложнение её кода.

 С приобретением определённого опыта у программиста появится
 возможность в простых и средней сложности программных блоках
 обходиться без тестирования или, по крайней мере, свести его к
 некоторому необходимому минимуму.

\subsection{Работа с вещественными числами}

Основная трудность при
работе с вещественными числами
  является следствием того факта, что любая переменная в памяти
  компьютера может принимать только конечное число значений, тогда
  как даже на конечном отрезке вещественной прямой содержится бесконечно много
  действительных чисел.

  Вещественные числа в компьютере представляются в т.\,н. {\it формате с
  плавающей точкой}~--- отдельно хранится \emph{мантисса} $M$, $|M| \leqslant
  1$, и \emph{порядок} $p$. Число вычисляется по формуле
  $$%%---------------------------------------
  M a^{p}.
  $$%%---------------------------------------
  Для
  записи мантиссы всегда используется фиксированное количество цифр,
  диапазон изменения порядка также ограничен. Поэтому машинное
  представление вещественных чисел имеет следующие, важные для
  практического программирования, особенности:
  \begin{itemize}
  \item[\textbf{a.}] в компьютере невозможно представить очень большие и
  очень малые по абсолютной величине действительные числа;
  \item[\textbf{b.}] вещественное число, даже и попадающее в допустимый
  диапазон, может быть записано с некоторой погрешностью.
  \end{itemize}

 Из свойства \textbf{a} непосредственно следует, что существует величина,
  называемая {\it машинным нулём}, т.\,е. такое число $\varepsilon$, что
  в компьютерных расчётах для всех чисел $x$, таких что $0 < x <
  \varepsilon$, выполняется $1.0 + x = 1.0$. Другими словами, все
  вещественные числа, меньшие $\varepsilon$, компьютер будет
  <<воспринимать>> как нуль. Величина машинного нуля зависит также от
  типа $x$.

  Из свойства \textbf{b} вытекает неизбежность
  ошибок округления, что можно показать на простом примере:

  %================================================================================
 \label{round_error_listing}
 \begin{lstlisting}
 program real_error;
 {$APPTYPE CONSOLE}
 uses SysUtils;
 const  x = 17.0;
 begin
 writeln(' ERROR = ', x - sqrt(x)*sqrt(x) );
 readln;
 end.
\end{lstlisting}
%================================================================================

Кроме этого, нужно всегда помнить, что погрешность при суммировании
чисел складывается из погрешностей слагаемых и погрешности
выполнения операции сложения. Если вначале складывать большие по
модулю числа, то можно получить неправильный результат.

 Рассмотрим пример суммирования первых $N$ членов ряда, задающего
 $\zeta$-функцию от~$2$
 $$
 \zeta(2) = \sum_{k = 1}^{\infty} \frac{1}{k^{2}} =
 \frac{\pi^2}{6}.
 $$

При суммировании в различном порядке можно получить различные результаты:

\begin{lstlisting}
 program  floatPrj_1;
 {$APPTYPE CONSOLE}
 uses  SysUtils;

 const  N               = 100000;
        dzeta2          = PI*PI/6;    // "точная" dzeta(2);
 var    k                :integer;
        S_to, S_downto  : real;

 begin
 S_to := 0;
    for  k := 1 to N do               // сумма по возрастанию k;
    S_to := S_to + 1/k/k;
 S_downto := 1/N/N;
    for  k := N - 1 downto 1 do       // сумма по убыванию k;
    S_downto := S_downto + 1/k/k;
 writeln( 'dzeta(2)  = ', dzeta2   );
 writeln( 'S_downto  = ', S_downto );
 writeln( 'S_to      = ', S_to     );
 readln;
 end.
 \end{lstlisting}



































%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
