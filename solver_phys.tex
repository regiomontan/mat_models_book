\subsection{Виброгаситель} \label{vibrodamp__otvet_1}

\textbf{Вопрос \ref{vibrodamp_vopros_1}.} Из уравнения
\eqref{vibro_damp_integral} получаем
$$%-----------------------------------------------------------------------------
 x_1 = -\frac{m_2}{m_1} \, x_2 - \frac{A}{\omega^2 m_1} \sin \omega t.
$$%-----------------------------------------------------------------------------
Подставляя это значение в \eqref{vibro_damp_model_1}, получим
дифференциальное уравнение
$$%-----------------------------------------------------------------------------
 m_2 \ddot{x}_2 + k\left(1 + \frac{m_2}{m_1} \right) x_2 +
  \frac{kA}{\omega^2 m_1} \sin \omega t = 0,
$$%-----------------------------------------------------------------------------
частное\footnote{По условиям вопроса нет необходимости находить \emph{общее} решение системы
                 \eqref{vibro_damp_model_1}--\eqref{vibro_damp_model_2}, отыскание
                 которого, впрочем, не представляет никаких сложностей.}
 решение которого не трудно найти подбором:
$$%-----------------------------------------------------------------------------
 x_2 = \frac{kA}{\omega^2\big(m_1 m_2 \omega^2 - k(m_1 + m_2)\big)} \sin \omega t.
$$%-----------------------------------------------------------------------------

На графиках \ref{graph_dampfer_omega} показаны поведение решений системы
уравнений \eqref{vibro_damp_model_1}--\eqref{vibro_damp_model_2} при различных значениях
параметра $\omega$.

%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 \begin{figure}[!h]
 \begin{center}
 \includegraphics[height = 0.9\textheight, width = 1.0\textwidth]
                  {pict/dampfer.pdf}
 \caption[Виброгаситель]
         {Виброгаситель, отклонения от величины $\omega$, определяемой соотношением
         \eqref{vibrodamp_omega}, сверху-вниз: 3\%, 1\%, точное значение}
 \label{graph_dampfer_omega}
 \end{center}
 \end{figure}
 %+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\subsection{Реалистичное освещение. Рейтрессинг} \label{raytrace_otvet}

\textbf{Вопрос \ref{raytrace_vopros_1}.}
Язык программирования "--- Object Pascal (Delphi). Будем использовать объектно-ориентированнвй
метод проектирования \cite{ZENKIN}.

Для того, чтобы иметь возможность работать с лучами света и задавать
 координаты точек в пространстве нужны \emph{векторы} "--- соответствующие процедуры
 и функции сосредоточим в классе \lstinline!Tvector! (см.~стр.~\pageref{base_class_vector}).
 Для работы с  \emph{цветами}
   нам понадобятся соответствующие процедуры
  и функции смешивания цветов~--- модуль  \lstinline!colorUnit!
  (см.~стр.~\pageref{color_class_listing}).
   Объект Луч, который нужен для работы с источником света, по существу является
   вектором, имеющим цвет, поэтому выведем соответствующий класс
   \lstinline!Tray! из класса \lstinline!Tvector!.
%%================================================================================
\begin{lstlisting}
Type Tray = class( Tvector )
 protected
 color                   : Tcvet;
 public
 function     get_source : Tvector;
 function     get_color  : Tcvet;
 constructor  birth( x0, y0, z0: double;
                     RR, GG, BB: integer  ); overload;
 constructor  birth( p0 :        Tpoint3d;
                     CC :        Tcvet    ); overload;
 end;
\end{lstlisting}
%%================================================================================

Несмотря на то, что в нашей модели только один тип тел "--- сфера, учитывая возможные
дальнейшие модификации программы,
   когда к сферам на сцену могут добавиться и другие виды объектов,
   сосредоточим общие для них методы в базовом классе
   \lstinline!Tfigure! (см.~стр.~\pageref{Tfigure_class_listing}).
   Этот класс содержит методы для расчёта отражённого луча,
   вычисления коэффициентов диффузии и отражения в заданной точке, для которых нужно
   знать \emph{нормаль} к данной точке.

   Поскольку нормаль можно
   определить только для конкретного тела, то метод
   \lstinline!set_normal! объявлен виртуальным и абстрактным, с тем, чтобы в дальнейшем
   иметь возможность его переопределения в производных классах.
%%================================================================================
\begin{lstlisting}
 type  Tfigure = class
 protected
 center     : Tvector;            // центр фигуры;
 normal     : Tvector;            // нормаль;
 reflected  : Tvector;            // отражённый луч;
 color      : Tcvet;              // цвет;
 n_spec     : double;             // показатель отражения;
 v_spec     : double;             // коэффициент отражения;
 procedure set_normal( point: Tvector ); virtual; abstract;
 procedure set_reflected( incident, p: Tvector );
 public
 function  get_reflected( incident, p: Tvector ): Tvector;
 function  get_diff( p, light_direction: Tvector ): double;
 function  get_spec( p, ray_direction: Tvector;
                     light_direction: Tvector ): double;
 function  get_value_spec: double;
 function  get_color: Tcvet;
 constructor  birth( center0: Tvector; color0: Tcvet;
                     n_spec0, v_spec0: double         );
 end;

\end{lstlisting}
%%================================================================================

Из класса \lstinline!Tfigure! выведем класс \lstinline!Tsphere!
   (сфера, стр.~\pageref{Tsphere_class_listing}). Объект этого класса должен иметь возможность
   рассчитывать вектор нормали к любой точке своей поверхности,
   определять факт пересечения трассирующего луча с поверхностью
   и, кроме того, определять расстояние до камеры. Для этого в
   классе \lstinline!Tsphere! заданы соттветствующие методы
   \lstinline!set_normal!  и \lstinline!intersection!,
   последний из которых возвращает множитель $t$, на который нужно умножить
   направляющий вектор трассирующего луча, чтобы этот луч попал на
   сферу. Если луч не попадает на сферу, то метод
   возвращает $-1{,}0$.

%%================================================================================
\begin{lstlisting}
 type  Tsphere = class( Tfigure )
 protected
 radius : double;
 procedure set_normal( point: Tvector ); override;
 public
 function  intersection( ray_origin    : Tvector;
                         ray_direction : Tvector  ): double;
 constructor  birth( center0: Tvector; color0: Tcvet;
                     n_spec0, v_spec0, radius0: double );
 end;
\end{lstlisting}
%%================================================================================

 В модуле \lstinline!traceUnit! (стр.~\pageref{trace_listing}) содержится процедура
   инициализации сцены \lstinline!init_scene! (используется левая координатная система~---
   см.~ри-
  %========================================================================
  \begin{wrapfigure}[9]{l}{0.37\textwidth}
  \vspace{-1.0cm}
  \begin{center}
  \includegraphics[height = 0.20\textheight, width = 0.37\textwidth]
  {pict/left_coord.pdf}
  %\caption{Левая коорд. система}
  \label{pict_left_coord}
  \end{center}
  \end{wrapfigure}
  %========================================================================
   сунок, считаем, что картинная плоскость фиксирована и совпадает с плоскостью XY),
   задающая положение
   камеры, источника света, количество и параметры сфер и т.\,д.,
   и \emph{трассировщик} "--- рекурсивная  функция
   \lstinline!trace!, которая собственно и выполняет всю основную
   работу по трассировке лучей. Головной модуль \lstinline!mainUnit!
   содержит процедуру отрисовки изображения, средства
   для поддержки управления программой и для сохранения трассированного изображения
   в файл. Пример трассировки показан на рис.~\ref{graph_trace}.

 %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 \begin{figure}[!h]
 \begin{center}
 \includegraphics[height = 0.43\textheight, width = 0.90\textwidth]
                  {pict/tracing_screen.jpg}
 \caption{Рейтрессинг сфер}
 \label{graph_trace}
 \end{center}
 \end{figure}
 %+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 Использованный нами объектно-ориентированный метод
  построения программы
  даёт при желании возможность легко и относительно просто дополнить сцену новыми
   объектами "--- любыми трёхмерными
   телами\footnote{Подробнее об основах объектно-ориентированного проектирования
                      см.~\cite{BADD}, \cite{BOOCH}, \cite{TAYLOR}.}.
   Подробное описание программы трассировки
   см.~в~\cite{ZENKIN}, её листинги "--- на стр.~\pageref{listings_raytracing}.

\textbf{Вопрос \ref{raytrace_optic_vopros_2}.} Решение начнем с вывода закона преломления Снелла.
Пусть луч света из среды, в которой он имеет скорость
$v_1$ попадает в среду, где его скорость равна $v_2$. Найдём,
применяя принцип Ферма, как связаны величины $v_1$, $v_2$ и
$\alpha_1$, $\alpha_2$ (см.~рис.~\ref{graph_Snell_solution}). Время, необходимое для
прохождения луча света от т.~$A$ до т.~$B$, равно
$$%------------------------------------------------------------------
 T(x) = \frac{\sqrt{a^2 + x^2}}{v_1} + \frac{\sqrt{b^2 + (c -
 x)^2}}{v_2}.
$$%------------------------------------------------------------------
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.31\textheight, width = 0.80\textwidth]
                  {pict/Snell_solution.pdf}
 \caption{К выводу закона преломления Снелла}
  \label{graph_Snell_solution}
 \end{center}
 \end{figure}
 %+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
В соответствии с принципом Ферма нужно найти минимум функции $T(x)$,
для чего, в частности, требуется решить уравнение
$$%------------------------------------------------------------------
 \frac{dT}{dx} = 0,
$$%------------------------------------------------------------------
откуда получим
$$%------------------------------------------------------------------
 \frac{x}{v_1 \sqrt{a^2 + x^2} } = \frac{c-x}{v_2 \sqrt{b^2 + (c - x)^2}},
$$%------------------------------------------------------------------
или, что то же самое,
$$%------------------------------------------------------------------
  \frac{\sin \alpha_1}{v_1} = \frac{\sin \alpha_2}{v_2}
$$%------------------------------------------------------------------

Равенство углов падения и отражения лучей света сразу следует из последнего соотношения,
если положить $v_1 = v_2$.

















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
