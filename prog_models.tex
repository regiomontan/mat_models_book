
\vspace{1.0em}

\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Для программирования необходима паранойя (в разумных
                 дозах) и твёрдая вера в справедливость законов Мерфи.
                 }} \\
                 %\end{flushright}
                 %\begin{flushright}
                 \emph{Д.~Тейлор и др., \cite{TAYLOR}} \\
\end{flushright}
\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Лучший способ в чём-то разобраться до конца "--- это попробовать научить
                 этому компьютер.
                 }} \\
                 %\end{flushright}
                 %\begin{flushright}
                 \emph{Дональд Эрвин Кнут}
\end{flushright}

Характерная черта компьютерных программ,
   соответствующих современным математическим моделям реальных
   явлений или систем некоторых объектов,~--- \emph{сложность.} Поскольку сложность программного
   обеспечения обусловлена сложностью реального мира, она неизбежна: с ней
   можно справиться при помощи различных приёмов, но полностью избавиться от неё нельзя.

   В следствие ограниченности человеческих мыслительных способностей~---
   человек может разом охватить программу из десятков, но не из
   десятков тысяч строк~--- возникает необходимость разбиения
   сложной программной системы на всё более и более простые
   подсистемы (декомпозиция). Такой способ управления сложными системами известен
   с древности~--- divide et impera (разделяй и властвуй). Он полезен не только в программировании,
   но и вообще при решении любых сложных задач, см., например,~ \cite{POYA}.
   Различают два основных вида такой декомпозиции:
   \begin{itemize}
    \item  \emph{объектно-ориентированная;}
    \item  \emph{алгоритмическая} (или \emph{структурная}).
   \end{itemize}

   При структурной декомпозиции производится разделение \emph{алгоритмов}, где каждый
   программный блок системы выполняет один из этапов общего
   процесса. При объектной декомпозиции разбиение производится по
   \emph{объектам} системы. При разделении по алгоритмам внимание концентрируется на порядке
   происходящих событий, а при разделении по объектам особое значение придается
   агентам, на которые направлены или которые сами вызывают
   какие-то действия. Легко видеть, что эти два подхода, по меньшей мере, неразумно
   применять одновременно.

   Алгоритмическая декомпозиция является основой для структурного
   проектирования в программировании. В языках, где используется такой подход, основной
   базовой единицей является \emph{подпрограмма}, а структуру программы в целом можно
   представить в форме <<дерева>>, в котором одни подпрограммы в процессе работы вызывают
   другие подпрограммы. Структурный подход реализован в таких
   языках высокого уровня, как, например, FORTRAN или COBOL.

   На идее объектно-ориентированной декомпозиции основан метод
   объектно-ориентированого проектирования. В его основе лежит представление о том, что
   программную систему необходимо проектировать как совокупность \emph{взаимодействующих друг
   с другом объектов}, рассматривая каждый объект как экземпляр определенного \emph{класса}
   (типа), причем классы образуют определённую структуру (иерархию). Объектно-ориентированный
   подход является основой последнего поколения языков высокого уровня, таких
   как Smalltalk, Object Pascal, C$++$, Java.

   Какой именно подход выбрать в данном конкретном случае зависит, главным образом, от
   решаемой задачи, а также от имеющихся в наличии программных средств (готовых модулей,
   библиотек и т.\,п.). Преимущества объектно-ориентированной декомпозиции
   проявляются, главным образом, в больших проектах со сложной
   структурой.

   Структурное проектирование можно условно подразделить на
    {\it процедурное}, когда основным <<строительным блоком>>
    при проектировании является подпрограмма и {\it модульное}, при котором
    основное внимание уделяется организации данных, а не алгоритмов, по которым
    эти данные обрабатываются. Модулем в последнем случае называют
    множество взаимосвязанных процедур вместе с  данными, которые эти процедуры
    обрабатывают. Эти два направления не исключают, а взаимно
    дополняют друг друга.

    При структурном проектировании декомпозиция достигается с
    помощью метода пошаговой детализации, который иногда называют
    {\it технологией программирования сверху вниз}. Идея метода состоит в
    том, что программа не пишется сразу на языке высокого уровня,
    а придумываются некие воображаемые {\it исполнители}, которые <<решают>>
    поставленные задачи. Если исполнителя невозможно или затруднительно сразу
    реализовать программно, то придумывается другой исполнитель,
    конкретизирующий действия первого, для второго исполнителя могут
    оказаться нужными другие исполнители и т.\,д., пока исполнители
    самого нижнего уровня не удастся записать на программном
    языке.

    Практически, при таком проектировании
    удобно записать программу, считая, что подзадачи, на которые она разбита, уже
    решены. После чего можно для каждой подзадачи писать отдельную
    программу (такие программы называют \emph{подпрограммами}), в случае, если это возможно.
    Если же непосредственная программная реализация подзадачи
    невозможна или по каким-то причинам неудобна, то эта подзадача
    снова разбивается на другие подзадачи и т.п. Чем сложнее
    исходная задача, тем больше получится уровней иерархии
    больше будет подпрограмм.

    Практически вначале вместо настоящих подпрограмм для исполнителей, в код вставляются фиктивные
    части "--- \emph{заглушки,} которые не делают ничего, кроме, быть может, выдачи сообщения о
    вызове.
    После того, как программист убедится, что общая структура
    программы верна, подпрограммы-заглушки последовательно заменяются на
    реально работающие. Для каждой подпрограммы процедура повторяется до тех пор, когда не останется
    ни одной заглушки. Подробнее см.~\cite{DAL_DEYKSTRA}, \cite{WIRTH}, \cite{KUSHNIRENKO_LEBEDEV}.

\subsection{Объектно-ориентированная декомпозиция} \label{OOP_decompose}

Наиболее естественно, просто и наглядно программная
 реализация математической модели в общем случае строится при использовании
 объектно-ориентированного подхода. К тому же, структурная
 декомпозиция становится затруднительной при программировании больших, сложных
 моделей. Основными преимуществами объектно-ориентированного метода
 по сравнению со структурным программированием являются:
 \begin{itemize}
 \item[---] лучшая применимость к моделированию реальных физических
            объектов и явлений;
 \item[---] {\it правильно выполненные} объектно-ориентированные
            проекты гораздо легче кодировать и сопровождать;
 \item[---] возможность повторного использования программного кода.
 \end{itemize}

 К недостаткам можно отнести необходимость более тщательного
 проектирования и, как правило, большее время, затрачиваемое на разработку
 программ.

 Базовыми понятиями объектно-ориентированного проектирования и
программирования
 (ООП) являются \emph{объекты} (они являются электронными аналогами
 моделируемых физических объектов)
  и \emph{классы}. Объект в ООП реально
 существует в памяти компьютера на этапе выполнения программы, а
 класс~--- это абстракция, которая задаёт общую структуру и
 поведение сходных объектов. Другими словами, класс~---
 это абстрактное множество объектов, имеющих общую структуру и поведение, а
 объект представляет собой экземпляр, представителя, имеющий \emph{тип} данного
 класса. Объект определяется своим \emph{состоянием},
 \emph{поведением} и \emph{именем} (идентификатором), позволяющим отличить его от объектов
 того же класса или других классов.
 Например, класс~--- {\small{\verb Homo_Sapiense }}, объекты этого класса~--- {\small{\verb Ivanoff }},
 {\small{\verb Petroff }}.

 У объекта можно выделить две важнейшие характеристики: интерфейс и
 реализацию. {\it Интерфейс} определяет как объект <<общается>> с
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 \begin{wrapfigure}[9]{l}{0.28\textwidth}
  \vspace{-2em}
 \begin{center}
 \includegraphics[height = 0.2\textheight, width = 0.28\textwidth]
 {pict/object.pdf}
 %\caption[$\enskip$ Объект]{Объект}
 \label{pict_object1}
 \end{center}
 \end{wrapfigure}
 %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 внешней средой (с пользователем, другими объектами, операционной
 системой). {\it Реализация}~--- это внутренние особенности объекта. Интерфейс и реализация
 объекта должны быть максимально независимы друг от друга в том
 смысле, что изменение внутренних функций не должно изменять
 соответствующего интерфейса.
  Можно условно представлять себе объект
 как <<чёрный ящик>> с окном, через которое объект
 взаимодействует с внешним миром (интерфейс). Это взаимодействие
 осуществляется через открытые (<<видимые>> в окне) методы, доступа к
 другим, закрытым, методам нет~--- они предназначены исключительно для внутренней
 реализации объекта (<<не видны>> в окне). Также не должно быть прямого доступа к данным,
 хотя многие языки программирования допускают нарушение этого
 принципа.

 Сам интерфейс организован посредством пересылки сообщений
 к объекту от <<окружающей среды>> и от объекта к <<внешнему>> миру.
 Основными базовыми принципами ООП являются:
 \begin{itemize}
 \item {\it инкапсуляция} (encapsulation);
 \item {\it наследование} (inheritance);
 \item {\it полиморфизм}  (polimorphism);
 \item {\it пересылка сообщений.}
 \end{itemize}
 {\it Инкапсуляция}~--- объединение в классе в единое целое данных (переменных, констант
 различных типов) и методов (процедур и функций), обрабатывающих эти
 данные. Данные класса это то, что объект этого класса <<знает>>,
 а методы~--- то, что он <<умеет>>. Например, для объектов класса
 {\small{\verb Homo_Sapiense }} данными могут быть: рост, цвет глаз,
 возраст, знание русского языка и арифметики, а методами~--- умение читать, писать
 и считать.

 {\it Наследование}. Любой класс может быть порождён от другого
 класса ({\it базового} или {\it родительского}). Порождённый класс ({\it потомок},
 {\it производный класс}) автоматически получает доступ к данным и методам
 родителя, т.\,е. наследует его структуру,
 и, кроме того, имеет возможности переопределять (<<улучшать>>) методы и дополняться
 новыми данными и методами.

 Например, классу {\small{\verb Programmer }}, наследнику класса
 {\small{\verb Homo_Sapiense }}, можно добавить свойство знания языка
 программирования C$++$ и метод~--- умение работать в IDE (интегрированных средах
 разработки), а спосо-
 %+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 \begin{wrapfigure}[12]{l}{0.42\textwidth}
 \vspace{-1.8em}
 \begin{center}
 \includegraphics[height = 0.26\textheight, width = 0.41\textwidth]
 {pict/inheritance.pdf}
 %\caption[$\enskip$ Объект]{Объект}
 \label{pict_object2}
 \end{center}
 \end{wrapfigure}
 %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 бность
 считать усовершенствовать до владения калькулятором.
 Точно так же, порождённый
  от {\small{\verb Homo_Sapiense }} класс
 {\small{\verb Мathematician }}
 можно наделить <<знанием>>, скажем, интегрального
 исчисления или топологии и добавить метод~--- умение интегрировать.
 Все свойства и
 методы базового класса {\small{\verb Homo_Sapiense }} будут также присущи любому
 объекту классов {\small{\verb Programmer }} и {\small{\verb Мathematician }}.
 Класс-потомок может, в свою очередь, быть базовым
 для другого класса. Таким образом, совокупность классов,
 связанных отношениями наследования, может образовывать иерархию или
 <<дерево>> классов любой сложности. У каждого класса может быть
 сколько угодно потомков. Что касается предков, то в некоторых
 языках программирования (например, C$++$) их может быть несколько,
 а в других (Object Pascal, C\#)  множественное наследование не
 допускается.

 \emph{Полиморфизм} даёт возможность решать сходные задачи
 различными способами. Для изменения метода родительского класса в
 классе-потомке его можно переопределить.
 Наследование позволяет различным типам данных совместно использовать один и тот же
 код, что приводит к уменьшению его размера и повышению функциональности, а полиморфизм
 перекраивает этот общий код так, чтобы удовлетворить конкретным особенностям отдельных
 типов данных.
 Практически полиморфизм часто
 реализуется через механизм т.\,н. \emph{виртуальных}  функций.

 Виртуальные функции позволяют объекту производного класса
 изменять поведение, определённое на уровне базового
 класса или обеспечить какие-либо возможности базового
 класса, которые он не может осуществить из-за того, что нужная
 для этого информация объявляется на уровне производного класса.
 Виртуальные методы позволяют объявить класс общего назначения, не
 требуя для этого знания конкретных особенностей, которые могут
 быть доступны только в производных классах.
 Например,
 поскольку для работы с различными IDE (Integrated Development Environment~--- интегрированная
 среда разработки) требуются различные навыки,
 то соотвествующий метод в {\small{\verb Programmer }} можно объявить
 виртуальным, а в классах-наследниках, которые назовём, к примеру,
 {\small{\verb Borland_Programmer }} и {\small{\verb Microsoft_Programmer }}, должным образом его
 переопределить, чтобы наш программист обрёл способность работать в
 Borland C$++$ Builder и Visual C$++$ соответственно.

 Другим важным понятием и принципом ООП является {\it пересылка
сообщений},
 которая содержательно выражает основную методологию построения
 объектно-ориентированных программ. Любой объект может отправлять сообщения
 другим объектам и принимать сообщения от них. При получении сообщения объекты
 выполняют определённые действия, причём разные объекты приняв
 одно и то же сообщение, вообще говоря, могут выполнять разные
 действия. Другими словами, поведение и реакция, инициируемые сообщением, зависят от
 объекта-получателя.
 Практически пересылка сообщений осуществляется вызовом
 соответствующего метода, обрабатывающего это сообщение. Сообщения
 это то, при помощи чего объекты <<общаются>> друг с другом.
 Например, для объекта класса {\small{\verb Programmer }} можно
 предусмотреть отправку сообщения объекту класса
 {\small{\verb Мathematician }} с запросом на вычисление некоторого
 интеграла.

 Таким образом, можно сформулировать следующее
 {\opred \textsl{ООП}~--- метод построения программ в виде множества
 взаимодействующих посредством передачи сообщений объектов, структура и поведение
 которых заданы соответствующими классами, и все эти классы
 принадлежат иерархии классов, выражающей отношение наследования.}\\


 Не трудно заметить аналогию между методами ООП и инженерным проектированием.
 Действительно, техническая система в  самом общем виде является совокупностью
 некоторых физических объектов и устройств (их электронные аналоги~--- объекты в ООП)
 различного типа (класса). Эти устройства обладают (инкапсулируют) некоторыми определёнными
 характеристиками (данные) и функциональностью (методы) и взаимодействуют между собой
 посредством каких-либо механических, электрических или иных связей (пересылка сообщений).
 Кроме этого, такую систему можно модифицировать, изменив свойства некоторых её объектов
 или добавив к ней новые (наследование и полиморфизм).

 \subsection{Объектно-ориентированное проектирование} \label{OOP_project}

 Сeйчас не существует единого и
универсального способа объектно-ориентированного
  проектирования. К настоящему времени не разработаны строгие методы классификации и нет
  правил, позволяющих выделять классы и объекты.
  Можно, однако, {\it рекомендовать} следующий порядок действий:

  \begin{enumerate}
    \item Разработку программы следует начать с анализа функционирования
          моделируемой системы, так как её поведение обычно известно задолго до
          всех остальных свойств. Затем следует спроектировать объекты и
          сообщения, которыми они будут обмениваться.
          \emph{После}\footnote
               { Подчеркнём, сначала проектируются объекты и
               система обмена сообщениями между ними, потом "---
               иерархия классов. Иначе, не зная как объекты взаимодействуют
               друг с другом, трудно или даже невозможно заранее определить
               какие методы будут нужны в каждом классе. Следует
               чётко понимать, что на этапе выполнения программы
               нет никаких классов, а существуют только объекты,
               структура и взаимодействие которых определены на основе иерархии
               классов. }
 определения того, как объекты
          будут <<общаться>> друг с другом, можно
          приступать к проектированию классов.
          %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          \begin{figure}[h]
          \begin{center}
          \includegraphics[height = 0.26\textheight, width = 0.65\textwidth]
          {pict/OOP.pdf}
          \caption{Процесс проектирования классов}
          \label{pict_OOP}
          \end{center}
          \end{figure}
          %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    \item Проектирование иерархии классов. Обработчики всех {\it общих}
          сообщений объединяйте в один базовый класс. Например, если
          имеется объект, получающий сообщения A, B, C и другой, получающий
          сообщения B, C, D, E, то нужно создать базовый
          класс, обрабатывающий сообщения B, C и два производных от него класса,
           один из которых будет содержать метод, обрабатывающий A, а другой~---
          методы, работающие с D и E. Если продолжать этот процесс, пока не
          будут исчерпаны все объекты, то в результате получится требуемая иерархия
          классов, в <<вершине>> которой будет располагаться самый общий
          класс, от которого наследуют все другие классы. Любой базовый
          класс должен иметь не менеее двух потомков. Возможности базового
          класса должны использоваться всеми его производными классами. Все методы,
          обрабатывающие сообщения объявите открытыми (public), а все
          другие, по возможности, должны быть закрытыми (private, protected).
     \item Данные добавляются в последнюю очередь. Для
           поддержки работы с
            данными на этом этапе также добавляются методы, которые должны быть \emph{закрытыми}, как и
          сами данные. Обращение
          к данным должно быть реализовано \emph{только с помощью методов
          класса}, т.\,е. интерфейс объекта с его окружением должен полностью определяться
          его методами, чтобы к его состоянию не было другого доступа извне, кроме как через
          методы \cite{BOOCH}, \cite{ZENKIN}.
  \end{enumerate}

  Может также оказаться полезным метод неформального описания модели,
 предложенный в книге \cite{BOOCH}. В словесном описании модели,
 программная реализация которой строится,
 выделяются существительные и глаголы. Существительные рассматриваются
 как кандидаты для образования классов, а глаголы --- кандидаты в операции над
 классами, т.\,е. для сообщений.

  Не трудно видеть, что принципы структурного проектирования,
  основанного, естественно, на структурном анализе, никак не соответствуют принципам
  объектно-ориентированного стиля разработки программ. Ни один из этих
  подходов не является <<лучшим>> или <<более правильным>> во всех ситуациях и задачах, но
  их не рекомендуется использовать одновременно в одном проекте.
  Опыт программирования показывает, что
  применение элементов структурного анализа в процессе объектно-ориентированного проектирования
  очень часто приводит к значительным трудностям при кодировании и, особенно, сопровождении
  программного продукта, или даже полному провалу проекта.

  Для более детального изучения различных аспектов разработки
 объектно-ориентированных
 проектов рекомендуются книги \cite{BOOCH} и \cite{BADD}, последняя
 содержит
 много примеров программ на различных языках программирования, а также \cite{SKLYROV},
 \cite{TAYLOR}.

\subsection{ООП в Delphi} \label{OOP_DELPHI}

  Delphi~--- это мощная, прекрасно организованная среда
 разработки для визуального программирования, основной компонент которой, Object Pascal,
 является объектно-ориентированным языком.

 Рассмотрим реализацию принципов ООП в среде Delphi. Формат объявления
 класса

  %%==============================================================================
 \begin{lstlisting}
 type  Tclass_name = class( Tbase_class )
                      // поля, методы и свойства
                      ...
                      end;
 \end{lstlisting}
 %%==============================================================================
 Здесь \lstinline!Tclass_name! "--- имя класса (имена классов в Delphi
 принято
 начинать с буквы T, но это не обязательно), \lstinline!Tbase_class!~--- имя
 родительского для \lstinline!Tclass_na!- \lstinline!me! класса, {\it полями} называют
 инкапсулированные в классе данные, {\it методы}~--- процедуры и функции,
 {\it свойства} (\lstinline!property!)~--- поля специального вида, регулирующие
 доступ к обычным полям. Класс может быть объявлен только в интерфейсной
 части модуля или самом начале области реализации, но не в разделе
 описаний подпрограмм.

 Дерево классов Object Pascal, имея в корне \lstinline!TObject!,
постепенно
 разрастается, включая всё новые и новые классы, каждый из которых
 обладает, кроме своих собственных, всеми возможностями своих
 предков. Из любого из этих классов программист может вывести свой
 собственный класс, добавив в него новые свойства и методы или переопределить
 родительские методы.

Для реализации графического интерфейса с пользователем Delphi
использует библиотеку VCL (Visual Component Library~--- библиотека
визуальных компонентов), которая содержит
 большое количество разнообразных классов, поддерживающих форму (окно) и различные
 её компоненты (командные кнопки, поля редактирования, меню и т.\,д.).
 Во время конструирования формы, по мере добавления на форму компонентов,  Delphi автоматически
 вписывает в текст программы необходимые объявления.

При создании классов доступ к его данным извне ограничивается.
 Хотя в Object Pascal можно в некоторых случаях напрямую обратиться к полям
 объекта, это считается отступлением от принципов ООП, согласно
 которым это обращение должно осуществляться только с помощью
 методов класса и никак иначе. Для ограничения доступа к данным и
 методам задаются различные {\it области видимости}.

В Delphi класс может содержать четыре секции, которые
 задают следующие области видимости:

 \begin{itemize}
 \item [1.] \lstinline!public! (общедоступные)~--- поля и методы
 этой секции доступны из любого модуля программы;
 \item [2.] \lstinline!published! (декларированные)~--- так же,
 как \lstinline!public!, не ограничивает области видимости,
 используется только при разработке пользовательских компонент VCL Delphi,
 свойства, объявленные в этой секции, будут доступны в окне Object
 Inspector;
 \item [3.] \lstinline!protected! (защищённые)~--- поля и методы
 доступны только методам самого класса и его потомков, независимо
 от того в каком модуле они находятся;
 \item [4.] \lstinline!private! (личные)~--- минимально возможная
 область видимости, приватные элементы доступны только потомкам
 класса, причём только тем, которые размещены в том же модуле.
 \end{itemize}
 Внутри каждой секции  вначале объявляются поля, а затем
 методы. Порядок следования секций произволен. По умолчанию, т.е.
 без явного задания ключевого слова, секция считается \lstinline!published!.

Класс может содержать два специальных метода:
 \lstinline!constructor! (конструктор) и \lstinline!destructor! (деструктор).
 В любом конструкторе вначале вызывается конструктор родителя с
  объявлением \lstinline!inherited,! а затем,
 обычно, выполняются некоторые инициализирующие действия. Конструктор
 размещает объект в динамической памяти (т.\,е. до вызова конструктора
 объект не существует!) и автоматически объявляет указатель
 \lstinline!Self! на выделенную объекту память. Деструктор
 уничтожает объект, возвращает память обратно в heap.
 Действия с объектом возможны только после вызова конструктора.

Методы базового класса можно изменять (перекрывать) в потомках,
причём это
 можно сделать как {\it статически}, так и {\it динамически}. При
 статическом изменении объявляется процедура с таким же именем,
 что и в родительском классе, но выполняющяя другие действия. При
 динамическом замещении метод родительского класса должен
 объявляться с директивой \lstinline!virtual! или
 \lstinline!dynamic!, а в классе-потомке~--- с директивой
 \lstinline!override!.

Динамические методы могут вообще не выполнять
 никаких действий и лишь перекрываться в потомках. Такие методы называют
 {\it абстрактными}. Они объявляются с директивой
 \lstinline!abstract!. Классы, содержащие такие методы, также называют
 абстрактными. Такие классы инкапсулируют методы, реализация
 которых откладывается до объявления соответствующего
 класса-потомка. Конечно, невозможно создать объект абстрактного класса и вызвать
 неперекрытый абстрактный метод.

 {\primer Создадим \textsl{заготовку для модели шахматной игры.}
 Объекты шахматные фигуры должны взаимодействовать с объектом
 шахматная доска согласно правилам.
 }\\

Объекты шахматные фигуры, очевидно, имеют общие
 свойства: цвет, координаты положения на доске и~др. В
 соответствии с этим создадим базовый класс
 %%==============================================================================
 \lstinputlisting{listings/chess/figure.pas}
 %%==============================================================================

Этот абстрактный класс содержит поле \lstinline!ID!~--- идентификатор фигуры,
 включающий её номер (№0~--- фигура отсутствует на доске, №1~--- король, №2~---
 ферзь, №3~--- ладья и т.\,д.), координаты на шахматной доске, цвет, а также объект
 \lstinline!board!~--- <<шахматная
 доска>> (объявления класса \lstinline!Tboard! и всех типов вынесены
 в отдельный модуль \lstinline!board.pas,! см.~ниже). Методы класса
 %%==============================================================================
 \lstinputlisting{listings/chess/figure_1.pas}
 %%==============================================================================

 %%==============================================================================
 \lstinputlisting{listings/chess/figure_2.pas}
 %%==============================================================================

 Класс
 \lstinline!Tboard! предназначен для поддержки графики и интерфейса с шахматными
 фигурами и, помимо прочего, содержит поле \lstinline!fig_board!~--- массив
 $8\times8$ идентификаторов фигур.
 %%==============================================================================
 \lstinputlisting{listings/chess/board.pas}
 %%==============================================================================

Фигура <<делает ход>>, посылая
 сообщение объекту \lstinline!board! отметить её положение в этом
 массиве. Поэтому, кроме конструктора и деструктора этот класс имеет метод
 \lstinline!move!, который осуществляет <<ход>> фигуры~--- посылает сообщение
 стереть запись своего текущего положения на доске и записать
 новые координаты в массив \lstinline!fig_board,! предварительно
 проверив допустимость данного хода.

 Правильность хода проверяет
 логическая функция \lstinline!can_move.! Поскольку эта функция
 индивидуальна для каждой фигуры, она объявлена абстрактной и
 будет впоследствии перекрываться в соответствующих классах.

 Далее приводятся только заголовки класса \lstinline!Tboard! и его
 методов, назначение всех процедур и функций должно быть вполне понятным из
 комментариев.

 %%==============================================================================
 \lstinputlisting{listings/chess/board_1.pas}
 %%==============================================================================

Из абстрактного класса \lstinline!Tfigure!  теперь можно выводить классы-потомки для
конкретных фигур, в частности определим производный класс
\lstinline!Tqueen! (ферзь).

Ограничимся
листингом лишь для класса \lstinline!Tqueen!, для других программный
код пишется аналогично.

 %%==============================================================================
 \lstinputlisting{listings/chess/queen.pas}
 %%==============================================================================

 Раздел реализации содержит, кроме конструктора и деструктора, только функцию
 проверки правильности хода ферзя: 

 %%==============================================================================
 \lstinputlisting{listings/chess/queen_1.pas}
 %%==============================================================================

 Теперь, при желании, легко можно продолжить добавлять другие фигуры, снова
 наследуя от базового класса \lstinline!Tfigure! \cite{ZENKIN}.





































   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
