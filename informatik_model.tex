
\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Информатика дала нам право на полную и безопасную манию величия.
                 }} \\
                 %\end{flushright}
                 %\begin{flushright}
                 \emph{Бернард Вербер. Революция муравьев} \\
\end{flushright}
\begin{flushright}
                 \parbox{0.8\textwidth}
                 {
                 \emph{Многие не сведущие в математике люди
                       думают, что поскольку назначение
                       аналитической машины Бэббиджа "--- выдавать результаты в численном виде,
                       то природа происходящих в ней процессов должна быть арифметической и
                       численной, а не алгебраической и аналитической. Но они ошибаются.
                 }} \\
                 \end{flushright}
                 \begin{flushright}
                 \emph{Августа Ада, графиня Лавлейс}
\end{flushright}

\subsection{L-системы}

L-системы (Lindenmayer-Systems) обычно употребляются для моделирования различных процессов, как
правило,
связанных с эволюцией каких-либо биологических и иных природных объектов:
кристаллов, раковин моллюсков, пчелиных сот и т.\,д. L-система определяется
специальным очень простым формальным языком (см.~определение на стр.~\pageref{def_lang}), который
представляет собой набор правил, задаваемых
текстовой
 записью, и предназначенных для графического представления объекта на плоскости. Отличительной
 особенностью языка L-систем является возможность представления визуально довольно сложных систем
 посредством простых команд~\cite{PRUSINK}.

  Можно считать, что графические построения L-систем реализуются при помощи
  специального \emph{исполнителя}, который в каждый момент времени
  <<знает>> свои координаты, направление движения и длину отрезка (длина отрезка
  постоянна, её можно выбрать произвольно на каждой итерации), на величину
  которого он может переместиться. Управляется исполнитель следующими
  командами:
  %-----------------------------------------------------------------------------
  \begin{center}
  \begin{tabular}{cll}
     F            &---& рисовать заданный отрезок в заданном направлении;\\
     f            &---& передвинуться в заданном направлении на заданный \\
                  &   & отрезок расстояния без рисования;\\
     \symbol{`\+} &---& изменить текущее направление против часовой стрелки на\\
                  &   & заданный угол;\\
     $-$          &---& изменить текущее направление по часовой стрелке на за-\\
                  &   & данный угол;\\
     \symbol{`\|} &---& реверс (поворот на $180^{\circ}$);\\
     \symbol{`\[} &---&  помеcтить в стек\footnotemark\ текущие координаты и направление;\\
     \symbol{`\]} &---&  вытолкнуть из стека координаты и направление и сделать\\
                  &   &   их текущими;\\
     \{           &---&  начало записи L-системы;\\
     \}           &---&  конец записи L-системы;\\
     ;            &---& комментарий до конца строки.
  \end{tabular}
  \end{center}\footnotetext{\label{stack_define} {\emph Стеком} (англ.  stack~--- стопка, пачка)
                               называют
                                структуру, в которой
                                накапливают некоторые элементы, причём обязательно
                                условие:  элементы из стека можно  доставать только
                                в порядке обратном порядку их помещения в стек "---
                                т.\,н. принцип LIFO (англ.~Last In~--- First Out,
                                <<последним пришёл "--- первым вышел>>).
                                На языках
                                высокого уровня стек обычно реализуется в виде
                                односвязного или двусвязного списка.}
  %-----------------------------------------------------------------------------

 Спецификация входных данных для описания L-систем представляет
 собой простой текстовый файл.
 В начале, до символа <<\{>>, принято задавать имя объекта. После
 символа начала записи задаётся текущий угол ---
 <<\lstinline !Angle n!>>,  угол равен $360^{\circ}$/n. Затем "--- т.\,н.
 \emph{инициатор}, аксиома <<\lstinline !Axiom S!>>, где \lstinline !S! "--- начальное значение
 строки команд,
 включающей один или  несколько текстовых символов, которая далее будет содержать
 команды исполнителю. Символ <<\lstinline !=!>> означает подстановку правой
 части вместо левой. Сама операция подстановки выполняется столько
 раз, сколько задаст пользователь (параметр \lstinline !Order!). Начальное
 направление по умолчанию равно $0^{\circ}$.

  Начальным состоянием L-системы является её аксиома.
  При дальнейшем развитии строка \lstinline !S!, описывающая состояние, будет меняться. Развитие
  L-системы происходит циклически \lstinline !Order! раз. В каждом цикле строка просматривается от
  начала  к концу, символ за символом, и для каждого из них  выполняется соответствующая подстановка,
  если он задан в аксиоме. Символы, не входящие в \lstinline !S!, не меняются.

 \emph{Пример 1.} Кривая Коха.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/koch.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 При \lstinline !Order = 1! строка команд имеет вид \lstinline !F+F--F+F!, при
 \lstinline !Order = 2!
  \lstinline !F+F--F+F + F+F--F+F -- F+F--F+F + F+F--F+F! и т.\,д.
  Соответственно будет меняться изображение
  кривой Коха, как показано на рисунке

%%-----------------------------------------------------------------------
\begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.06\textheight, width = 0.98\textwidth]
 {pict/koch.pdf}
  \vspace{0.8ex}
  \caption{Кривая Коха}
  \label{pict_koch_pdf}
 \end{center}
 \end{figure}
%%------------------------------------------------------------------------

Кривая Коха является классическим примером геометрического фрактала и обладает
множеством замечательных свойств. Алгоритм построения: исходный единичный отрезок разделяется на
три равные части и средний интервал заменяется
 равносторонним треугольником без основания. В результате получится
ломаная, состоящая из четырех звеньев длины $1/3$. На следующем шаге операция повторяется  для
каждого из четырёх получившихся звеньев и т.\,д. Предельная кривая, после бесконечного числа
шагов, является кривой Коха.

\emph{Пример 2.} <<Дерево>> (Order = 1, 2, 3, 4).
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/tree.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.32\textheight, width = 0.7\textwidth]
 {pict/tree.pdf}
 \vspace{0.8ex}
  \caption{L-дерево}
  \label{pict_L_tree_pdf}
 \end{center}
 \end{figure}
%%------------------------------------------------------------------------

\emph{Пример 3.} <<Цветок>> (Order = 4).
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/rose.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.16\textheight, width = 0.3\textwidth]
 {pict/rose_04.pdf}
 \vspace{0.8ex}
  \caption{L-цветок}
  \label{pict_L_rose_04_pdf}
 \end{center}
 \end{figure}
 %%------------------------------------------------------------------------


\emph{Пример 4.} <<Солнце>> (Order = 4, 5, 6).
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/sun.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.325\textheight, width = 0.82\textwidth]
 {pict/sun.pdf}
 \vspace{0.8ex}
  \caption{L-солнце}
  \label{pict_L_sun_pdf}
 \end{center}
 \end{figure}
 %%------------------------------------------------------------------------

 \emph{Пример 5.} <<Орнамент>> (Order = 4).
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/expl.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.22\textheight, width = 0.92\textwidth]
 {pict/expl_04.pdf}
 \vspace{0.8ex}
  \caption{L-орнамент}
  \label{pict_L_expl_04_pdf}
 \end{center}
 \end{figure}
 %%------------------------------------------------------------------------


 \emph{Пример 6.} <<Куст>> (Order = 2, 3, 4).
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/bush.l}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.4\textheight, width = 0.8\textwidth]
 {pict/bush.pdf}
 \vspace{0.8ex}
  \caption{L-куст}
  \label{pict_L_bush_pdf}
 \end{center}
 \end{figure}
 %%------------------------------------------------------------------------

\subsection{Транслятор с языка L-систем на PostScript}

Для качественного визуального представления и хранения изображений, построенных на основе L-систем,
необходимо перевести их в подходящий графический формат.
В связи со спецификой языка L-систем эту задачу можно решить используя  \emph{векторный} формат,
например, EPS (Encapsulated PostScript,
 разновидность PostScript). В  данном случае особенно важны преимущества векторных форматов
 графики над растровыми, такие как: простота масштабирования
 изображения, относительно малый размер файлов и~др.

\textbf{Основы языка PostScript.} \label{PS_basics_lang}
Язык PostScript был разработан фирмой
 Adobe Systems в 1982~г и создавался в качестве
 средства описания вида текста, чертежей и изображений на печатаемой странице так, чтобы это
 описание не зависело от устройства,  на котором страница будет воспроизведена.

 Язык PostScript содержит около~250 операторов. Около трети средств языка
 предназначены для графики, остальная часть~--- это процедурный язык
 программирования \cite{ADOBE_EPS}. Файлы PostScript (PS, EPS) представляют
 собой
 обычный текст, который одновременно является исходной программой для
 интерпретатора и одним из форматов \emph{векторной} графики. Интерпретатор
 PostScript способен
 принять на вход этот файл с описанием страницы и преобразовать его в
 \emph{растровую} форму, которая затем выводится на печать или на экран монитора.
 В настоящее время
 наиболее распостранён интерпретатор Ghostscript (\cite{GHOSTSCRIPT}, портирован на
 платформы MS~Windows, OS/2, GNU~Linux).

 Формат EPS является разновидностью PostScript. Главные отличия
 состоят в том, что EPS-файлы могут иметь только одну страницу и
 предназначаются в основном для хранения векторных изображений. В
 соответствии с \cite{ADOBE_EPS} минимальный EPS-файл имеет вид
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \lstinputlisting{listings/lsystem/minimal.eps}
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 где \lstinline !minX!, \lstinline !minY!, \lstinline !maxX!, \lstinline
 !maxY!~--- минимальные и максимальные координаты изображения.

 В связи со спецификой языка описания L-систем из всего
 многообразия возможностей PostScript нам понадобится только
 следующие два оператора, задающие соответственно перемещение
 <<пера>> в точку с координатами \lstinline !(x,y)! и рисование
 отрезка от текущего положения пера до точки с координатами
 \lstinline !(x,y)!:
  %%----------------------------------------------------------
  \begin{lstlisting}
    x  y   moveto
    x  y   lineto
  \end{lstlisting}
 %%----------------------------------------------------------

\textbf{Транслятор}\label{def_translator} (англ.~translator "--- переводчик) "---
специальная
 программа, преобразующая исходную программу, написанную на одном алгоритмическом языке,
 в программу на другом языке. Транслятор может быть двух типов:

 \begin{description}
   \item[\hspace{1.5em}Компилятор]    (англ.~compile "--- составлять, собирать,
                        накапливать) "--- программа, переводящяя исходную программу в
                        эквивалентную ей объектную программу, записанную, как правило, на
                        некотором машинном языке.
   \item[\hspace{1.5em}Интерпретатор] (англ.~interpreter "--- переводчик,
                        истолкователь) отличается от компилятора тем, что вместо
                        перевода исходной программы в объектный код, сразу выполняет
                        инструкции, записанные на входном языке. Наряду с тем
                         достоинством, что интерпретатор непосредственно выполняет все
                       команды, он имеет по сравнению с компилятором существенный
                       недостаток: интерпретируемые программы выполняются во много
                       раз медленнее программ, представленных в машинных кодах.
 \end{description}

 Транслятору необходимо произвести анализ исходной программы,
 лексический\footnote
            {
            \emph{Лексика} (от греч. {\small $\gr{l}\acute{\gr{e}}\gr{xis}$}~---
            слово, речь, выражение)~--- словарный состав какого-либо
            языка, совокупность слов, входящих в состав языка. В
            данном случае лексика~--- правила, по которым слова
            (лексемы) составляются из отдельных символов.
            },
  синтаксический\footnote
                 {
                  См. сноску на стр.~\pageref{def_syntax}.
                 }
  и семантический\footnote
                 {
                 \emph{Семантика} (греч. {\small$\gr{shmantik}\acute{\gr{o}}\gr{s}$}~---
                 обозначающий)~--- смысл, который имеет каждая конструкция языка.
                 },
   и затем
 сгенерировать объектную программу. Характерным свойством
 трансляции является то, что этот процесс не является линейным, т.\,е. преобразование
 исходной программы не последовательно. Трансляция обычно включает
 несколько фаз анализа исходной программы.

 \emph{Лексический анализатор}
 (\emph{сканер})~--- самая простая часть транслятора. Сканер
 читает символы из входного потока и строит из них лексемы\footnote
                 {
                 \emph{Лексема} (от греч. {\small $\gr{l}\acute{\gr{e}}\gr{xis}$}~---
                 слово, речь, выражение)~--- единица лексического уровня языка,
                 представляющая собой слово во всей совокупности его
                 значений. Например, все формы слова <<логика>> и
                 различные значения этих форм в различных
                 сочетаниях: <<формальная логика>>, <<математическая логика>>,
                 <<женская логика>> и т.\,д. тождественны как
                 выразители одной и той же лексемы. В данном
                 случае лексемы~--- слова в соответствии с определениями
                 языка.
                 }: идентификаторы,
 константы, служебные слова, знаки операций и т.\,п., которые затем передаются на
 обработку синтаксическому анализатору. Кроме этого, сканеру также можно поручить
 простейшие действия, не требующие анализа исходной программы,
 как-то: удаление комментариев, занесение идентификаторов в
 информационные таблицы и др. Фактически лексический анализатор представляет собой
 конечный автомат, см.~стр.~\pageref{DEF_finite_automat}.

 \emph{Синтаксический} и \emph{семантический анализаторы}
 выполняют наиболее сложную работу и являются основными  компонентами при трансляции.
 Когда синтаксический анализатор получает от сканера лексему и
 <<узнаёт>> её как конструкцию языка, он вызывает соответствующую
 семантическую процедуру.
 Существуют программы для \emph{автоматической} генерации синтаксических
 анализаторов, одну из которых~--- Bison~--- мы используем далее.

 %%-----------------------------------------------------------------------
 \begin{figure}[h]
 \begin{center}
 \includegraphics[height = 0.46\textheight, width = 0.64\textwidth]
 {pict/translate_scheme.pdf}
 \vspace{0.8ex}
  \caption{Схема трансляции в простейшем случае~\cite{KOSTELCEV},
           пунктирами изображены информационные потоки}
  \label{translate_scheme_pdf}
 \end{center}
 \end{figure}
 %%------------------------------------------------------------------------

 \textbf{Генератор синтаксических анализаторов Bison} \label{BISON}
 преобразует описание контекстно-свободной LALR(1)\footnote
                    {
                     <<Look Ahead Left Recursive>>~--- леворекурсивный
                     <<с заглядыванием>>, предпросмотром. Метод грамматического разбора, считается
                     менее мощным, чем <<чистый>> LR, но нуждается в таблицах
                     меньшего размера. LR(k) разбор осуществляет восходящий
                     грамматический анализ с правосторонним выводом, используя
                     для определения следующего действия не более k лексических
                     единиц. Алгоритм LALR(1) описан в статье \cite{LALR_parse}.
                    }
 грамматики в программу на языке C для разбора этой грамматики \cite{KOSTELCEV}.
 Bison написан Робертом Корбеттом (Robert Corbett) при участии Ричарда Столлмена
 (Richard Stallman), Вильфреда Хансена (Wilfred Hansen) и др. Bison обратно совместим
 с другим известным генератором синтаксических анализаторов Yacc.

 Bison обеспечивает общее средство для придания определенной структуры входным
 данным компьютерных программ. Пользователь готовит
 спецификацию процесса ввода; она включает в себя правила,
 описывающие структуру входных данных, код, вызываемый, когда
 распознаны эти правила, процедуру для ввода данных и лексический
 анализатор~--- функция \lstinline !yylex()!. Затем Bison генерирует
 функцию \lstinline !yyparse()! (синтаксический анализатор), контролирующую
 процесс ввода. Синтаксический анализатор вызывает \lstinline !yylex()! для извлечения
 элементарных объектов (лексем) из входного потока. Эти лексемы должны быть
 организованы в соответсвии с правилами структуризации входных данных, называемых
 \emph{грамматическими правилами}. Когда одно из этих правил распознается,
 вызывается пользовательский код для этого правила, или \emph{действие};
 действия способны возвращать значения и использовать значения
 других действий.

 \emph{Входные данные для Bison\label{BISON_spec}}.
 Ядром спецификаций ввода является система грамматических
 правил, записываемых в виде близком к нормальной форме Бэкуса~--- Наура
 (см. стр.~\pageref{BNF}).
 Каждое правило описывает допустимую структуру и дает ей
 имя. Hапример, грамматическое правило может выглядеть так:
 %%----------------------------------------------------------
  \begin{lstlisting}
                 date : month_name day ',' year;
  \end{lstlisting}
 %%----------------------------------------------------------
 Здесь \lstinline !date!, \lstinline !month_name!, \lstinline !day! и
 \lstinline !year! представляют
 собой структуры для процесса ввода; предполагается, что
 \lstinline !month_name!, \lstinline !day! и \lstinline !year! определены
 где-либо еще. Запятая <<,>> заключена в одиночные
 кавычки; это значит, что она должна появиться в тексте
 буквально. Двоеточие и точка с запятой служат просто как знаки
 препинания в правиле и не имеют никакого значения при контроле
 входных данных. Таким образом, при должных определениях ввод
 %%----------------------------------------------------------
  \begin{lstlisting}
                       October 25, 1917
  \end{lstlisting}
 %%----------------------------------------------------------
 будет соответствовать вышеуказанному правилу.

 Входные данные могут не соответствовать спецификациям. Эти ошибки
 данных определяются настолько рано, насколько возможно при чтении
 слева-направо; таким образом, не только в значительной степени
 понижается вероятность чтения и работы с неправильными данными, но
 и неверные данные могут быть быстро обнаружены.

 Каждый файл спецификаций состоит из трех секций: объявления,
 грамматические правила и программы. Секции разделяются
 символами двойного процента <<\%\%>>. (Символ процента <<\%>> в основном
 используется в Bison как Esc-символ.)

 Другими словами, полный файл спецификации выглядит как
 %%----------------------------------------------------------
 \begin{lstlisting}
               описания
               %%
               правила
               %%
               программы
 \end{lstlisting}
 %%----------------------------------------------------------
 Секция описаний может быть пуста. Более того, если секция
 программ опущена, то
 вторая метка \%\% также может быть опущена. Таким образом, минимальная разрешенная
 спецификация для Bison есть
 %%----------------------------------------------------------
 \begin{lstlisting}
               %%
               правила
 \end{lstlisting}
 %%----------------------------------------------------------
 Пробелы, табуляции и новые строки игнорируются, за исключением
 случаев, когда они появляются в именах или многосимвольных
 зарезервированных словах. Комментарии могут появляться везде, где
 разрешено имя; они заключаются в \lstinline !/* . . . */!,
 как в языке C.

 Секция правил построена из одного или более грамматических
 правил, имеющих вид:
 %%----------------------------------------------------------
 \begin{lstlisting}
               A : BODY ;
 \end{lstlisting}
 %%----------------------------------------------------------
 \lstinline !A! представляет собой нетерминальное имя, а \lstinline !BODY!
 представляет собой
 последовательность нуля или более имен и литералов. Двоеточие и
 точка с запятой~--- пунктуация Bison.

 Имена допускаются произвольной длины и могут состоять из букв,
 точек <<.>>, подчерков <<\_>> и неначальных цифр. Заглавные и строчные
 буквы различаются. Имена, используемые в теле грамматических
 правил могут представлять cобой токены и нетерминальные символы. Литерал
 состоит из символов, заключенных в одиночные кавычки <<\lstinline !'!>>.

 Каждый нетерминальный символ должен появляться в левой части как минимум
 одного правила. Среди всех нетерминальных символов один, называемый
 \emph{стартовым} символом, имеет особенную важность. Парсер разработан так, чтобы
 распознавать стартовый символ; таким образом, этот символ
 представляет самую большую, самую общую структуру, описанную
 грамматическими правилами. По умолчанию стартовый символ берется
 из левой части первого грамматического правила в секции правил.
 Возможно и даже желательно, явно объявить стартовый символ в
 секции объявлений, используя ключевое слово \lstinline !%start!:
 %%----------------------------------------------------------
 \begin{lstlisting}
               %start keyword
 \end{lstlisting}
 %%----------------------------------------------------------

 \emph{Действия.}\label{BISON_action}
 Каждому грамматическому правилу пользователь может приписать
 \emph{действия}, исполняемые каждый раз, когда распознается правило во
 входных данных. Эти действия могут возвращать значения, и получать
 значения, возвращенные предыдущими действиями. Более того,
 лексический анализатор может возвращать значения токенов, если это
 необходимо.

 Действие~--- это произвольный C-оператор, и поэтому может
 производить ввод и вывод, вызывать подпрограммы, изменять внешние
 структуры и переменные. Действие обозначается одним или более
 операторами, заключенными в фигурные скобки <<\lstinline !{!>> и <<\lstinline !}!>>.
 Hапример,
 %%----------------------------------------------------------
 \begin{lstlisting}
               A    :  '(' B ')'   { hello( 1, "abc" ); }
  \end{lstlisting}
 %%----------------------------------------------------------
 и
 %%----------------------------------------------------------
 \begin{lstlisting}
     XXX  : YYY ZZZ      { printf( "a message\n" ); flag = 25; }
 \end{lstlisting}
 %%----------------------------------------------------------
 являются грамматическими правилами с действиями.

 Чтобы вернуть значение, действие обычно устанавливает
 псевдопеременную <<\lstinline !$$!>> в некоторое значение. Hапример, действие,
 которое ничего не делает, а только возвращает значение 1, это
 %%----------------------------------------------------------
 \begin{lstlisting}
               { $$ = 1 }
 \end{lstlisting}
 %%----------------------------------------------------------

 Чтобы получить значения, возвращенные предыдущими действиями и
 лексическим анализатором, действие также может использовать
 псевдопеременные \lstinline !$1!, \lstinline !$2!, \ldots, которые относятся
 к значениям,
 возвращенным компонентами в правой части правила, при его чтении
 слева направо. Таким образом, если правило, скажем, такое
%%----------------------------------------------------------
 \begin{lstlisting}
               A    : B C D ;
 \end{lstlisting}
 %%----------------------------------------------------------
 то \lstinline !$2! имеет значение, возвращенное \lstinline !C!, а
 \lstinline !$3!~--- значение, возвращенное \lstinline !D!.

 Как более конкретный пример, представим правило
 %%----------------------------------------------------------
 \begin{lstlisting}
               expr : '(' expr ')' ;
 \end{lstlisting}
 %%----------------------------------------------------------
 Значение, возвращенное этим правилом~--- это обычное значение
 \lstinline !expr! в
 скобках. Это может быть выражено так:
 %%----------------------------------------------------------
 \begin{lstlisting}
               expr : '(' expr ')'  { $$ = $2 ; }
 \end{lstlisting}
 %%----------------------------------------------------------
 По умолчанию значение правила~--- это значение первого элемента в
 нем (\lstinline !$1!). Таким образом, грамматическое правило вида
 %%----------------------------------------------------------
 \begin{lstlisting}
               A :  B ;
 \end{lstlisting}
 %%----------------------------------------------------------
 часто не требует явного действия.

 \emph{Лексический и синтаксический анализ.}\label{BISON_lexical_synt}
 Пользователь должен предоставить лексический анализатор для чтения
 входных данных и передавать токены (со значениями, если надо)
 парсеру. Лексический анализатор~--- это функция,
 называемая \lstinline !yylex()!. Функция возвращает целое число, номер токена,
 представляющий вид прочитанного токена. Если с этим токеном
 связано \emph{значение}, оно должно быть присвоено внешней переменной
 \lstinline !yylval!.По историческим причинам, маркер конца должен иметь номером токена
 $0$ или отрицательное число. Этот номер токена не может быть
 переопределен пользователем; таким образом, \emph{все} лексические
 анализаторы должны быть написаны так, чтобы возвращать $0$ или
 отрицательное число при достижении конца своих входных данных.


 Парсер, созданный Bison, является конечным автоматом со
 стеком (см.~стр.~\pageref{DEF_pushdown automaton}). Парсер также способен
 читать и запоминать следующий входной токен (называемый \emph{lookahead token}).
 Текущее состояние~---
 всегда на вершине стека. Состояниям конечного автомата
 присваиваются небольшие целые метки; изначально автомат находится в
 состоянии 0, и не прочитано ни одного \emph{lookahead token}'a.

 Автомату доступно только четыре действия, называемые \emph{сдвиг (shift)},
 свертка \emph{(reduce)}, \emph{принятие (accept)} и \emph{ошибка (error)}.
 Каждый шаг разбора происходит следующим образом:
 %%--------------------------------------------------------
 \begin{itemize}
 \item[1.] Основываясь на текущем состоянии парсер определяет, нужен ли
 ему \emph{lookahead token} для решения, какое действие нужно произвести;
 если ему требуется \emph{lookahead token} и он его не имеет, то вызывает
 \lstinline !yylex()! для получения следующего токена.
 \item[2.] Используя текущее состояние и, если необходимо, \emph{lookahead token}
 парсер принимает решение о следующем действии и производит его.  В
 результате состояния могут быть записаны в стек или прочитаны из
 него или \emph{lookahead token} обработан или оставлен неизменным.
\end{itemize}
 %%---------------------------------------------------------
 Действие сдвига~--- самое частое действие, которое производит
 парсер. Когда исполняется действие сдвига, всегда есть \emph{lookahead token}.
 Hапример, в состоянии 56 может быть действие:
 %%---------------------------------------------------------
 \begin{center}
 {\verb IF  shift  34 }
 \end{center}
 %%---------------------------------------------------------
 которое означает, в состоянии 56, если \emph{lookahead token}
 есть {\verb IF }, текущее
 состояние (56) продвигается дальше в стеке, и состояние 34
 становится текущим (на вершине стека). \emph{lookahead token} очищается.

 Действие свертки предохраняет стек от неограниченного
 возрастания. Свертки соответствуют тому, что парсер
 <<увидел>> правую часть правила и готовится объявить, что он увидел
 случай, подчиняющийся правилу, заменяя его правую часть на левую.
 Действие свертки также важно при обработке пользовательских
 действий и значений. Когда происходит свертка, код, связанный с
 правилом исполняется перед тем как стек выравнивается. В
 дополнение к стеку, содержащему правила, параллельно ему работает
 еще один, содержащий значения, возвращенные лексическим
 анализатором и действиями. Когда происходит сдвиг, внешняя
 переменная \lstinline !yylval! копируется на стек значений. После возврата из
 пользовательского кода происходит свертка. Когда происходит
 действие перехода, внешняя переменная \lstinline !yylval! копируется на стек
 значений. Псевдопеременные \lstinline !$1!, \lstinline !$2! и т.\,д. ссылаются
 на стек значений.

 Остальные два действия парсера значительно проще.
 Действие принятия сигнализирует о том, что просмотрены все входные
 данные и они соответсвуют спецификации, это  происходит
 только когда \emph{lookahead token} есть маркер конца и сигнализирует,
 что парсер
 успешно завершил работу. Действие ошибки
 обозначает место, с которого парсер не может продолжать
 разбор в соответствии со спецификацией. За входным токеном, вместе
 с \emph{lookahead token} не может следовать ничего, что является верными данными.
 Парсер сообщает об ошибке и пытается
 продолжить разбор, если это возможно.

 \textbf{Транслятор} \lstinline !L2eps! напишем на языке C для операционной системы
 Windows, см.~листинги на~стр.\pageref{listings_transl}. Его  портирование на другие платформы не
 представит никаких трудностей.

 Порядок компиляции и сборки следующий:
\begin{itemize}
  \item [---] исходные файлы \lstinline !L2eps.y!,
              \lstinline !Lsyst.h!, \lstinline !Lsyst.c!, \lstinline !EPS.h!,
              \lstinline !EPS.c! поместить в отдельную директорию;
  \item [---] запустить Bison
              %%---------------------------------------------------------
              \begin{center}
              \lstinline !bison.exe  -lvg L2eps.y!,
              \end{center}
              %%---------------------------------------------------------
              после чего Bison создаст головной файл \lstinline !L2eps.tab.c!, содержащий
              синтаксический анализатор и, кроме того,
              \lstinline !файл L2eps.out!-\lstinline !put!~--- разбор грамматики и
              \lstinline !L2eps.vcg!~--- <<дерево>> разбора в специальном формате для
              визуализации графов VCG;
  \item [---] cкомпилировать и собрать проект.
\end{itemize}

 Транслятор работает из коммандной строки, формат
 вызова:
 %%---------------------------------------------------------
 \begin{center}
  \lstinline !L2eps.exe  L_файл.l  EPS_файл.eps  Order  нач_угол!
 \end{center}
 %%---------------------------------------------------------
 Последний параметр не обязателен, начальный угол по умолчанию
 равен $0$. В соответствии с описанием L-системы, содержащемся в
 \lstinline !L_файл.l!, будет сгенерирован файл \lstinline
 !EPS_файл.eps!.

 Изображения
 \ref{pict_koch_pdf}, \ref{pict_L_tree_pdf},
 \ref{pict_L_rose_04_pdf}, \ref{pict_L_sun_pdf},
 \ref{pict_L_expl_04_pdf}, \ref{pict_L_bush_pdf},
 приведенные выше,
 построены программой \lstinline !L2eps! по соответствующим L-кодам.

\subsection{Простейшие клеточные автоматы} \label{elementary_cellular_automaton}

Стивен Вольфрам, известный разработкой системы компьютерной алгебры Mathematica и системы
извлечения знаний WolframAlpha, предложил новый метод моделирования сложных
систем \cite{WOLFRAM}, основываясь на
предположении, что любая система состоит из многих более или менее идентичных простых элементов с
ограниченным числом возможных состояний. Состояние элементов зависит от состояний расположенных рядом
элементов и правил, определяющих эту зависимость. Таким образом, данные простые элементы можно
трактовать как клеточные автоматы, см.~стр.~\pageref{DEF_finite_automat}.

Наиболее простым и, в то же время, нетривиальным клеточным автоматом
является \emph{одномерный} (решетка автомата представляет собой одну строку клеток)
клеточный автомат с \emph{двумя возможными состояниями} ($0$, $1$ или, скажем, черный и белый
цвета), при котором соседями
клетки считаются две смежные с ней в строке клетки. Таким образом, три клетки
(текущая клетка с соседями)
могут принимать $2^3 = 8$ различных состояний. Правило перехода, т.\,е.~будет ли на следующем шаге
центральная клетка тройки <<белой>> или <<чёрной>>, задаётся исходя из состояния тройки, например,
как показано на рис.~\ref{cell_elements_0_pdf}.

%========================================================================
 \begin{figure}[h]
 \begin{center}
  \includegraphics[height = 0.07\textheight, width = 0.92\textwidth]
 {pict/cell_elements_90.pdf}
 \vspace{-0.4\abovecaptionskip}
 \caption{Правило перехода $90$ $(90 = 01011010_2)$}
 \label{cell_elements_0_pdf}
 \end{center}
 \end{figure}
%========================================================================

 Нумерация правил определяется переводом бинарной последовательности, определяющей правило, в
 десятичное представление, "--- например на рис.~\ref{cell_elements_0_pdf} задано правило $90$.
 Последовательное применение данного правила приводит к генерации фрактала, известного как
 треугольник Серпинского, или «салфетка» Серпинского.

 %========================================================================
 \begin{figure}[h]
 \begin{center}
  \includegraphics[height = 0.20\textheight, width = 0.998\textwidth]
 {pict/cell_elements_90mesh2.pdf}
 %\vspace{-0.4\abovecaptionskip}
 \caption{Элементарный клеточный автомат с правилом $90$ генерирует
          «салфетку» Серпинского}
 \label{cell_elements_90mesh2_pdf}
 \end{center}
 \end{figure}
%========================================================================

Правило под номером $30$ порождает последовательность, кажущуюся случайной, при неслучайных начальных
условиях "--- Стивен Вольфрам использует его для генерации псевдослучайных целых чисел в пакете Mathematica.
Эволюция системы по правилу $30$ демонстрирует апериодическое, хаотическое поведение.
Вольфрам считает, что, наряду с другими, правило $30$ "--- ключ к пониманию того, как простые правила могут
порождать сложные структуры и различное сложное поведение разных природных объектов.

Правило $184$ используется в качестве простой модели транспортного потока на однополосном шоссе:
каждая клетка автомата соответствует транспортному средству, которое движется вперед, если она имеет открытое
пространство перед ней "--- на каждом шаге клетка в состоянии~$1$, справа от которой находится клетка в состоянии
$0$ (<<свободное место>>), перемещается вправо, освобождая занятое пространство
(см.~рис.~\ref{cell_elements_184_pdf}). Поэтому это
правило называют иногда <<дорожным правилом>>. В физике аэрозолей правило $184$ применяется для
моделирования осаждения частиц на нерегулярную поверхность.

%========================================================================
 \begin{figure}[h]
 \begin{center}
  \includegraphics[height = 0.07\textheight, width = 0.92\textwidth]
 {pict/cell_elements_184.pdf}
 \vspace{-0.4\abovecaptionskip}
 \caption{Правило перехода $184$}
 \label{cell_elements_184_pdf}
 \end{center}
 \end{figure}
%========================================================================

Для программной реализации простейшего клеточного автомата дополнительно примем, что
последняя ячейка каждой строки совпадает с первой. См.~листинги на стр.~\pageref{listings_cell_auto}.
















































%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
